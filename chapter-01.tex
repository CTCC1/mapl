\chapter{Введение}
\label{chap:intro}

\epigraph{
1. Запишите задачу на бумаге.\\
2. Подумайте действительно хорошенько.\\
3. Запишите решение задачи.
}{<<Алгоритм Фейнмана>>, по Мюррею Гелл-Манну.}


Представьте себе такую задачу. Вам нужно посетить все города, городки и поселки, например, Швеции и вернуться в исходную точку. Это может занять немало времени (ведь нужно заглянуть в 27 978 мест), так что Вам хочется сделать маршрут покороче. Вы собираетесь заехать в каждое место только один раз следуя кратчайшим путем. Будучи программистом Вы точно не собираетесь рисовать маршрут вручную. Вместо этого Вы попробуете написать программу, которая все рассчитает сама. Однако, по какой-то причине Вам это никак не удается. Очевидное решение неплохо работает на небольшом количестве городов, но на реальной задаче расчет никак не завершается, а улучшить программу оказывается неожиданно сложно. Как быть?

Между тем, в 2004-ом году команда из 5 исследователей\footnote{David Applegate, Robert Bixby, Vašek Chvátal, William Cook, and Keld Helsgaun} нашла такой путь по Швеции, после того как несколько подобных проектов завершились неудачей. Эта команда использовала самое новое ПО с кучей хитрых оптимизаций, запущенное на кластере из 96 машин на Xeon 2.6ГГц. Их программа проработала с марта 2003-го до мая 2004-го, прежде чем было получено оптимальное решение. Ребята посчитали, что с учетом разных перерывов общее процессорное время, потраченное на решение задачи, оказалось равным \textit{85 годам}!

Представьте теперь похожую задачу: из Кашгара, на самого западе Китая, Вам нужно попасть в Нинбо, на восточное побережье, следуя кратчайшем путем. В Китае 3 583 715 км автомобильных и 77 384 км железных дорог, которые пересекаются в миллионах мест и образуют неисчислимое количество возможных маршрутов. Может показаться, что эта проблема аналогична предыдущей, но уже сейчас такая задача \textit{поиска кратчайшего пути} решается без каких-либо затруднений и задержек GPS-навигаторами и онлайн-картами. Если Вы отметите два этих города на любимом картографическом сервисе, то получите кратчайший маршрут за пару мгновений. Так в чем же тут дело?

Дальше в книге Вы узнаете больше о двух этих задачах. Первая называется \textit {проблемой коммивояжера} и описана в главе \ref{chap:hard-problems}, а так называемая проблема поиска кратчайшего пути рассматривается в главе \ref{chap:from-a-to-b}. Я надеюсь, что Вы начнете хорошо понимать, почему одни задачи так сложны для решения, в то время как другие имеют несколько известных и эффективных решений. Что еще важнее, Вы научитесь работать с любыми вычислительными и алгоритмическими задачами, либо эффективно решая их, используя описанные в книге техники и алгоритмы, либо показывая, что они слишком сложны, и приближенное решение "--- это лучшее, на что можно рассчитывать. Эта глава вкратце описывает всю книгу: что Вы можете от нее получить и что требуется от Вас. В ней также обозначены темы остальных глав, чтобы Вы могли читать их выборочно.


\begin{lstlisting}[caption={An Iterative Solution to the Longest Common Subsequence (LCS)}]
def lcs(a,b):
    n, m = len(a), len(b)
    pre, cur = [0]*(n+1), [0]*(n+1) # Previous/current row
    for j in range(1,m+1): # Iterate over b
        pre, cur = cur, pre # Keep prev., overwrite cur.
        for i in range(1,n+1): # Iterate over a
            if a[i-1] == b[j-1]: # Last elts. of pref. equal?
                cur[i] = pre[i-1] + 1 # L(i,j) = L(i-1,j-1) + 1
            else: # Otherwise...
                cur[i] = max(pre[i], cur[i-1]) # max(L(i,j-1),L(i-1,j))
    return cur[n] # L(n,m)
\end{lstlisting}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "mapl"
%%% End: 
